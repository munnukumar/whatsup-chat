import crypto from "crypto";
import axios from "axios";
import WebSocket from "ws";
import EventEmitter from "events";
import { ValidationError, validator } from "./utils/validationError.js";

class TwinProtocol extends EventEmitter {
  constructor({ TP_ACCESS_KEY, TP_SECRET_KEY, TP_CLIENT_ID, TP_BASE_URL, TP_WS_URL }) {
    super();
    this.apiKey = TP_ACCESS_KEY;
    this.apiSecret = TP_SECRET_KEY;
    this.baseUrl = TP_BASE_URL;
    this.clientId = TP_CLIENT_ID;
    this.brainId = null;
    this.currentQuery = null;
    this.isInitalize = false;
    this.initQuery = "Hello";
    this.twinName = null;
    this.currentWordLimit = 100;
    this.category = "general";
    this.ws = null;
    this.wsUrl = TP_WS_URL;

    this.httpClient = axios.create({
      baseURL: this.baseUrl,
      headers: {
        "Content-Type": "application/json",
        "API-Key": this.apiKey,
      },
    });
  }

  // queryFrame to create a payload for chat functionality
  queryFrame(
    query,
    twinName = this.twinName,
    wordLimit = this.currentWordLimit,
    brainId = this.brainId,
    category = this.category
  ) {
    return {
      query: query,
      twinName: twinName,
      wordLimit: wordLimit,
      brainId: brainId,
      category: category,
    };
  }

  // request calls the respective API
  async request(method, endpoint, payload, options = {}) {
    const timestamp = Date.now().toString();
    const signature = this.sign(timestamp, {
      apikey: this.apiKey,
      clientid: this.clientId,
    });

    const headers = {
      timestamp: timestamp,
      signature: signature,
      apikey: this.apiKey,
      clientid: this.clientId,
      ...options.headers,
    };

    try {
      const response = await this.httpClient.request({
        method,
        url: endpoint,
        headers,
        data: payload
      });
      return response;
    } catch (error) {
      throw error;
    }
  }

  // sign generates the signature
  sign(timestamp, data) {
    const message = this.apiKey + timestamp + JSON.stringify(data);
    return crypto
      .createHmac("sha256", this.apiSecret)
      .update(message)
      .digest("hex");
  }

  // returns the response from message event
  wsOnMessage(event) {
    const response = JSON.parse(event.data);
    this.emit("message", JSON.parse(event.data));
    return response;
  }

  // returns the errors coming from ws
  wsOnError(error) {
    this.emit("stream_error", error.message);
    return error;
  }

  // init initializes sdk
  async init(brainId = "66cc8afc63dafb7a528a9eda", twinName = "javascript") {
    this.brainId = brainId ?? "";
    this.twinName = twinName;
    let res = "";
    const {
      success = false,
      message = "",
      data = null,
    } = await this.request("POST", "/v1/chat/twin", {
      ...this.queryFrame(
        this.initQuery,
        this.twinName,
        this.wordLimit,
        this.brainId
      ),
    }).catch((e) => {
      console.log({
        error: e.message,
      });
      res = `initalization failed | ${e.message} `;
    });

    if (success) {
      // connect websocket
      await this.connectToWebsocket();
      res = "initalization done";
      this.isInitalize = true;
      this.ws.onmessage = this.wsOnMessage.bind(this);

      console.log("SDK initialized successfully!");
    }

    return { message: res, status: this.isInitalize };
  }

  // query hits the REST API to chk if everything is configured correctly
  async query(query = this.initQuery) {
    if (this.isInitalize) {
      const {
        success = false,
        message = "",
        data = null,
      } = await this.request("POST", "/v1/chat/twin", {
        ...this.queryFrame(query),
      }).catch((e) => {
        console.log({
          error: e.message,
        });
        res = `chat failed  | ${e.message} `;
        this.isInitalize = false;
      });

      if (success) {
        return { message: data, status: true };
      } else {
        return { message: "Something went wrong!", status: false };
      }
    } else {
      return { message: "TwinProtocol SDK is not initalized", success: false };
    }
  }

  // connectToWebsocket creates connection to ws backend
  async connectToWebsocket() {
    let timestamp = Date.now().toString();
    let data = {
      apikey: this.apiKey,
      clientid: this.clientId,
    };
    let signature = this.sign(timestamp, data);

    return new Promise((resolve, reject) => {
      this.ws = new WebSocket(
        `${this.wsUrl}?apikey=${this.apiKey}&signature=${signature}&timestamp=${timestamp}&clientid=${this.clientId}`
      );

      this.ws.onopen = () => {
        console.log("WebSocket connection established");
        resolve();
      };
      this.ws.onmessage = this.wsOnMessage.bind(this);
      this.ws.onclose = () => {};

      this.ws.onerror = (error) => {
        console.error("WebSocket error:", error);
        reject(error);
      };
    });
  }

  async stream(
    query = this.initQuery,
    type = "query_wa",
    brainId = this.brainId,
    twinName = this.twinName
  ) {
    const msg = {
      query,
      brainId: brainId,
      twinName: twinName,
      wordLimit: 100,
      type: type,
    };
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      try {
        await this.connectToWebsocket();
      } catch (error) {
        throw error;
      }
    }

    this.ws.send(JSON.stringify(msg));

    // Wait for a response from the WebSocket server
  }

  async streamResponse(data, twinName) {
    const msg = {
      data,
      twinName,
      type: "stream_response",
    };
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      try {
        await this.connectToWebsocket();
      } catch (error) {
        throw error;
      }
    }
    this.ws.send(JSON.stringify(msg));
  }

  async queryWebsocket(query = this.initQuery, type, brainId, twinName) {
    const msg = {
      query,
      brainId: brainId,
      twinName: twinName,
      wordLimit: 100,
      type: type,
    };
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      try {
        await this.connectToWebsocket();
      } catch (error) {
        throw error;
      }
    }

    this.ws.send(JSON.stringify(msg));

    // Wait for a response from the WebSocket server
    return new Promise((resolve, reject) => {
      this.ws.onmessage = (event) => {
        const response = JSON.parse(event.data);
        console.log(response);
        resolve(response);
      };

      this.ws.onerror = (error) => {
        console.error("WebSocket error:", error);
        reject(error);
      };
    });
  }

  // generates the video response
  async generateVideoResponse(input, sourceUrl) {
    validator.validate({
      input: { value: input, type: "string" },
      sourceUrl: { value: sourceUrl, type: "string" },
    });

    try {
      const response = await this.request(
        "POST",
        "/v1/video-generation/speak-content",
        {
          input,
          sourceUrl,
        }
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  //generates the video response for given input text and twin id
  async twinVideoResponse(input, twinId, stitch) {
    validator.validate({
      input: { value: input, type: "string" },
      twinId: { value: twinId, type: "string" },
      stitch: { value: stitch, type: "boolean", required: false },
    });

    const payload = { input, twinId };
    if (typeof stitch === "boolean") {
      payload.stitch = stitch;
    }

    try {
      const response = await this.request(
        "POST",
        "/v1/video-generation/twin-video",
        payload
      );
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async twinWebHookVideoResponse(input, twinId) {
    validator.validate({
      input: { value: input, type: "string" },
      twinId: { value: twinId, type: "string" },
    });

    try {
      const response = await this.request(
        "POST",
        "/v1/video-generation/twin-webhook-video",
        { input, twinId }
      );
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  //generates the compressed video response for given input text and twin id
  async twinCompressedVideo(input, twinId) {
    validator.validate({
      input: { value: input, type: "string" },
      twinId: { value: twinId, type: "string" },
    });

    try {
      const response = await this.request(
        "POST",
        "/v1/video-generation/compressed-video",
        {
          input,
          twinId,
        }
      );

     return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  //fetches all twins from database with pagination
  async getAllTwins({ page, limit }) {
    validator.validate({
      page: { value: page, type: "number" },
      limit: { value: limit, type: "number" },
    });

    try {
      const response = await this.request("GET", "/v1/twin/getAllTwins", {
        page,
        limit,
      });
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async getMedia(vaultId) {
    validator.validate({
      vaultId: { value: vaultId, type: "string", required: true },
    });

    try {
      const response = await this.request(
        "GET",
        `v1/vault/get-media?vaultId=${vaultId}`
      );
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  // Sets up a new D-ID stream connection for a twin
  async setupConnection(twinId, responseResolution, stitch=null, sessionTimeout=null) {
    validator.validate({
      twinId: { value: twinId, type: "string" },
      responseResolution: { value: responseResolution, type: "number" },
      stitch: { value: stitch, type: "boolean", required: false,},
      sessionTimeout: { value: sessionTimeout, type: "number", required: false,},
    });

    try {
      const response = await this.request(
        "POST",
        "/v1/video-generation/stream/create",
        {
          twinId,
          responseResolution,
          stitch,
          sessionTimeout
        }
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async startStream(streamId, input, twinId, sessionId) {
    validator.validate({
      streamId: { value: streamId, type: "string" },
      input: { value: input, type: "string" },
      twinId: { value: twinId, type: "string" },
      sessionId: { value: sessionId, type: "string" },
    });

    try {
      const response = await this.request(
        "POST",
        "/v1/video-generation/startStream",
        {
          streamId,
          input,
          twinId,
          sessionId,
        }
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async startConnection(streamId, answer, sessionId) {
    validator.validate({
      streamId: { value: streamId, type: "string" },
      answer: { value: answer, type: "object" },
      sessionId: { value: sessionId, type: "string" },
    });

    try {
      const response = await this.request(
        "POST",
        "/v1/video-generation/startConnection",
        {
          streamId,
          answer,
          sessionId,
        }
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async sendNetworkInfo(streamId, sessionId, candidate, sdpMid, sdpMLineIndex) {
    validator.validate({
      streamId: { value: streamId, type: "string" },
      sessionId: { value: sessionId, type: "string" },
      candidate: { value: candidate, type: "object", required: false },
      sdpMid: { value: sdpMid, type: "string", required: false },
      sdpMLineIndex: { value: sdpMLineIndex, type: "number", required: false },
    });

    try {
      const response = await this.request(
        "POST",
        "/v1/video-generation/sendNetworkInfo",
        {
          sessionId,
          candidate,
          sdpMid,
          sdpMLineIndex,
          streamId,
        }
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async twinBasedOnId(id) {
    validator.validate({
      id: { value: id, type: "string" },
    });

    try {
      const response = await this.request("GET", `/v1/twin/getTwinById/${id}`);

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async getTwinImage(id) {
    validator.validate({
      id: { value: id, type: "string" },
    });

    try {
      const response = await this.request("GET", `/v1/twin/getTwinImage/${id}`);

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async getTwinByName(personalityName, page, limit) {
    validator.validate({
      personalityName: { value: personalityName, type: "string" },
      page: { value: page, type: "number", required: false },
      limit: { value: limit, type: "number", required: false },
    });

    try {
      const queryParams = { page, limit };
      const response = await this.request(
        "GET",
        `v1/twin/getTwinByName/${personalityName}`,
        queryParams
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async createConnectionRequest(twinId, categoryIds) {
    validator.validate({
      twinId: { value: twinId, type: "string" },
      categoryIds: { value: categoryIds, type: "object" },
    });

    try {
      const response = await this.request(
        "POST",
        "/v1/twin/createConnection",
        {
          twinId,
          categoryIds,
        }
      );
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async getConnectionRequests(twinId, categoryId) {
    validator.validate({
      twinId: { value: twinId, type: "string" },
      categoryId: { value: categoryId, type: "string", required: false },
    });

    try {
      const response = await this.request(
        "GET",
        "/v1/twin/getConnection",
        { twinId, categoryId }
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async streamTextAndAudioResponse(
    twinId,
    text,
    modelId = "eleven_turbo_v2_5",
    stability = 0.6,
    similarityBoost = 0.75
  ) {
    validator.validate({
      twinId: { value: twinId, type: "string" },
      text: { value: text, type: "string" },
      modelId: { value: modelId, type: "string", required: false },
      stability: { value: stability, type: "number", required: false },
      similarityBoost: {
        value: similarityBoost,
        type: "number",
        required: false,
      },
    });

    try {
      const response = await this.request(
        "POST",
        "/v1/audio/generate",
        {
          twinId,
          text,
          modelId,
          stability,
          similarityBoost,
        }
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async streamAudio(twinId, text, modelId = "eleven_flash_v2_5") {
    validator.validate({
      twinId: { value: twinId, type: "string" },
      text: { value: text, type: "string" },
      modelId: { value: modelId, type: "string", required: false },
    });

    try {
      const response = await this.request(
        "POST",
        "/v1/audio/stream",
        {
          twinId,
          text,
          modelId,
        }
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async userWithMemory() {
    try {
      const response = await this.request("POST", "/v1/persona/create-user");

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async createPersonality(formData) {
    validator.validate({
      formData: {
        value: formData,
        type: "formData",
        required: true,
      },
    });

    try {
      const response = await this.request(
        "POST",
        "/v1/persona/create-personality",
        formData,
        {
          headers: {
            "Content-Type": "multipart/form-data",
          },
        }
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async saveMedia(formData) {
    validator.validate({
      formData: {
        value: formData,
        type: "formData",
      },
    });

    try {
      const response = await this.request(
        "POST",
        "/v1/vault/save-media-file",
        formData,
        {
          headers: {
            "Content-Type": "multipart/form-data",
          },
        }
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async fetchPersonality(personalityId) {
    validator.validate({
      personalityId: { value: personalityId, type: "string" },
    });

    try {
      const response = await this.request(
        "GET",
        `/v1/persona/personality/${personalityId}`
      );
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async getAllPersonalities() {
    try {
      const response = await this.request(
        "GET",
        "/v1/persona/all-personalities"
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async deletePersonality(personalityId) {
    validator.validate({
      personalityId: { value: personalityId, type: "string" },
    });

    try {
      const response = await this.request(
        "DELETE",
        `/v1/persona/delete-personality/${personalityId}`
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async updatePersonality(personalityId, formData) {
    validator.validate({
      personalityId: { value: personalityId, type: "string" },
      formData: { value: formData, type: "formData" },
    });

    try {
      const response = await this.request(
        "PUT",
        `/v1/persona/update-personality/${personalityId}`,
        formData,
        {
          headers: {
            "Content-Type": "multipart/form-data",
          },
        }
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async createSession(userId, personalityId) {
    validator.validate({
      userId: { value: userId, type: "string" },
      personalityId: { value: personalityId, type: "string" },
    });

    try {
      const response = await this.request(
        "POST",
        "/v1/persona/create-session",
        {
          userId,
          personalityId,
        }
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async EditSessionTitle(sessionId, title) {
    validator.validate({
      sessionId: { value: sessionId, type: "string" },
      title: { value: title, type: "string" },
    });

    try {
      const response = await this.request(
        "PUT",
        `/v1/persona/edit-Session/${sessionId}`,
        { title }
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async createScript(
    sessionId,
    message,
    userId,
    personalityId,
    charLimit,
    modelName,
    language,
    context_scope
  ) {
    validator.validate({
      sessionId: { value: sessionId, type: "string" },
      message: { value: message, type: "string" },
      userId: { value: userId, type: "string" },
      personalityId: { value: personalityId, type: "string" },
      charLimit: { value: charLimit, type: "number" },
      modelName: { value: modelName, type: "string" },
      language: { value: language, type: "string" },
      context_scope: { value: context_scope, type: "string" },
    });

    const payload = {
      sessionId,
      message,
      userId,
      personalityId,
      charLimit,
      modelName,
      language,
      context_scope,
    };

    try {
      const response = await this.request(
        "POST",
        "/v1/persona/create-script",
        payload
      );
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async getSpecificSession(sessionId) {
    validator.validate({
      sessionId: { value: sessionId, type: "string" },
    });

    try {
      const response = await this.request(
        "GET",
        `/v1/persona/session/${sessionId}`
      );
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async getAverageSessionTime() {
    try {
      const response = await this.request("GET", "/v1/persona/session-average");
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async sendMessage(sessionId, message, userId, personalityId) {
    validator.validate({
      sessionId: { value: sessionId, type: "string" },
      message: { value: message, type: "string" },
      userId: { value: userId, type: "string" },
      personalityId: { value: personalityId, type: "string" },
    });

    try {
      const response = await this.request(
        "POST",
        `/v1/persona/message/${sessionId}`,
        { message, userId, personalityId }
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async sessionHistory(sessionId) {
    validator.validate({
      sessionId: { value: sessionId, type: "string" },
    });

    try {
      const response = await this.request(
        "GET",
        `/v1/persona/session-history/${sessionId}`
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async createChat(
    sessionId,
    message,
    userId,
    personalityId,
    wordLimit,
    modelName,
    language
  ) {
    validator.validate({
      sessionId: { value: sessionId, type: "string" },
      message: { value: message, type: "string" },
      userId: { value: userId, type: "string" },
      personalityId: { value: personalityId, type: "string" },
      wordLimit: { value: wordLimit, type: "number" },
      modelName: { value: modelName, type: "string" },
      language: { value: language, type: "string" },
    });

    try {
      const payload = {
        sessionId,
        message,
        userId,
        personalityId,
        wordLimit,
        modelName,
        language,
      };
      const response = await this.request(
        "POST",
        "/v1/persona/create-chat",
        payload
      );
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async createTwinTvChat(
    firstPersonalityId,
    secondPersonalityId,
    conversationType,
    topic
  ) {
    validator.validate({
      firstPersonalityId: {
        value: firstPersonalityId,
        type: "string",
      },
      secondPersonalityId: {
        value: secondPersonalityId,
        type: "string",
      },
      conversationType: {
        value: conversationType,
        type: "string",
      },
      topic: { value: topic, type: "string" }
    });

    const payload = {
      firstPersonalityId,
      secondPersonalityId,
      conversationType,
      topic
    };

    try {
      const response = await this.request(
        "POST",
        "/v1/persona/create-twintv-chat",
        payload
      );
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async findMatchingMemory(answer, userId) {
    validator.validate({
      answer: { value: answer, type: "string" },
      userId: { value: userId, type: "string" },
    });

    try {
      const payload = { answer, userId };
      const response = await this.request(
        "POST",
        "/v1/persona/chatreference",
        payload
      );
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async getUserDetails(userId) {
    validator.validate({
      userId: { value: userId, type: "string" },
    });

    try {
      const response = await this.request(
        "GET",
        `/v1/persona/fetch-user-data/${userId}`
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async deleteSessionHistory(sessionId) {
    validator.validate({
      sessionId: { value: sessionId, type: "string" },
    });

    try {
      const response = await this.request(
        "DELETE",
        `/v1/persona/session-delete/${sessionId}`
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async deleteSession(sessionId) {
    validator.validate({
      sessionId: { value: sessionId, type: "string" },
    });

    try {
      const response = await this.request(
        "DELETE",
        `/v1/persona/delete/${sessionId}`
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async deleteFile(personalityId, fileName) {
    validator.validate({
      personalityId: { value: personalityId, type: "string" },
      fileName: { value: fileName, type: "string" },
    });

    try {
      const response = await this.request("DELETE", `/v1/persona/file-delete?fileName=${fileName}&personalityId=${personalityId}`);
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async verifyOtp(email, otp) {
    validator.validate({
      email: { value: email, type: "string" },
      otp: { value: otp, type: "string" },
    });

    try {
      const response = await this.request("POST", "/v1/vault/verify-otp", {
        email,
        otp,
      });

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async createVaultId(email, platformId) {
    validator.validate({
      email: { value: email, type: "string" },
      platformId: { value: platformId, type: "string" },
    });

    try {
      const response = await this.request("POST", "/v1/vault/create", {
        email,
        platformId,
      });

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async importVault(vaultId, platformId) {
    validator.validate({
      vaultId: { value: vaultId, type: "string" },
      platformId: { value: platformId, type: "string" },
    });

    try {
      const response = await this.request("POST", "/v1/vault/import", {
        vaultId,
        platformId,
      });

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async saveData(payload) {
    try {
      let headers = {};
      const isFormData = payload && typeof payload.getHeaders === "function";

      if (isFormData) {
        validator.validate({
          formData: {
            value: payload,
            type: "formData",
          },
        });

        headers = payload.getHeaders();
      } else {
        validator.validate({
          body: {
            value: payload,
            type: "object",
          },
        });

        headers = { "Content-Type": "application/json" };
      }

      const response = await this.request(
        "POST",
        "/v1/vault/save-data",
        payload,
        { headers }
      );

      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async getCommunities() {
    try {
      const response = await this.request("GET", "/v1/on1/communities");
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async getCommunity(communityId) {
    validator.validate({
      communityId: { value: communityId, type: "string" },
    });

    try {
      const response = await this.request(
        "GET",
        `/v1/on1/community/${communityId}`
      );
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }

  async getAllTwinsTV() {
    try {
      const response = await this.request("GET", "/v1/twin/getAllTwinsTv");
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
    }
  }

  async getTwinByPersonalityId(personalityId) {
    validator.validate({
      personalityId: { value: personalityId, type: "string" },
    });

    try {
      const response = await this.request(
        "GET",
        `/v1/twin/tv/${personalityId}`
      );
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
    }
  }

  async deleteStream(streamId, sessionId) {
    validator.validate({
      streamId: { value: streamId, type: "string" },
      sessionId: { value: sessionId, type: "string" },
    });

    try {
      const response = await this.request(
        "DELETE",
        "/v1/video-generation/deleteStream",
        {
          streamId,
          sessionId,
        }
      );
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
    }
  }

  async fullStreamFlow(twinId) {
    validator.validate({
      twinId: { value: twinId, type: "string" },
    });

    try {
      const response = await this.request(
        "POST",
        "/v1/video-generation/stream/full",
        { twinId }
      );
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
    }
  }

  async demoSession(personalityId) {
    validator.validate({
      personalityId: { value: personalityId, type: "string" },
    });

    const payload = { personalityId };

    try {
      const response = await this.request(
        "POST",
        "v1/persona/create-demo-session",
        payload
      );
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
    }
  }

  async demoChat(
    sessionId,
    message,
    personalityId,
    wordLimit,
    modelName,
    language
  ) {
    validator.validate({
      sessionId: { value: sessionId, type: "string" },
      message: { value: message, type: "string" },
      personalityId: { value: personalityId, type: "string" },
      wordLimit: { value: wordLimit, type: "number" },
      modelName: { value: modelName, type: "string" },
      language: { value: language, type: "string" },
    });
    const payload = {
      sessionId,
      message,
      personalityId,
      wordLimit,
      modelName,
      language,
    };

    try {
      const response = await this.request(
        "POST",
        "v1/persona/create-demo-chat",
        payload
      );
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
    }
  }

  async getSessionDetailsByVaultId(vaultId) {
    validator.validate({
      vaultId: { value: vaultId, type: "string" },
    });
  
    try {
      const response = await this.request(
        "GET",
        `v1/twin/session-details?vaultId=${vaultId}`
      );
      return response.data;
    } catch (error) {
      if (error.response && error.response.data) {
        throw error.response.data;
      }
      throw error;
    }
  }
  

  closeWebSocket() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
}

export default TwinProtocol;
